// Additive Modal Synthesis using BiQuad ResonZ filter
//    to resynthesize the plinked Plate sound
// by Perry R. Cook, 2015

// You can use this as a model to do your own
//  Modal synthesis.  More modes, fewer modes,
// it's all good.  Listen, and...  Experiment!! 

//  NOTE:  Edit the Residue file (generated by FFTFindModes.ck
//         if you are using it for excitation.  Trim the front
//         to very tight, or even into the point where the level
//         is near the peak.  Trim the tail a whole lot.

// Modal Resynthsis Class, uses ResonZ filters for modes
class ModalSynth extends Chubgraph {
    10 => int NUM_MODES;
    ResonZ modes[NUM_MODES];

//     frequency  ,  gain  (could add time constant here too)
    [[ 585.332599 , 0.750212 ],   // these are the modes from the
     [ 1230.084229 , 0.971846 ],    // plate we whacked in the
     [ 1911.071777 , 0.849900 ],      // online video
     [ 2010.662842 , 0.378065 ],
     [ 2670.117188 , 1.000000 ],  // replace them with your own from
     [ 3071.173096 , 0.104546 ],  //    your analysis of your object/sound
     [ 3563.745117 , 0.098136 ],
     [ 4465.447998 , 0.043037 ],  // NOTE:  number of entries here should
     [ 4556.964111 , 0.027220 ],  //    equal NUM_MODES
     [ 5499.041748 , 0.104922 ]]  // which you can change if you like!   
     @=> float freqsNamps[][];

//    You could fill this array with measured or guess-timated time constants
// [ 2.0, 1.9, 1.8, 1.7, 1.6, 1.5, 1.4, 1.3, 1.2, 1.1 ] @=> float T60s[];
//   or build them in as a third number for each entry above
//   see code below on how to use them.

// use this for residual (or other wave file) excitation
//     NOTE:   See residue file note above
SndBuf excite;
me.dir() + "Residue.wav" => excite.read;
excite.samples() => excite.pos;
    
// Or/and use this for enveloped noise excitation
//    Noise n => ADSR excite;
//    (sample,10::ms,0.0,ms) => excite.set;

// Or use this for an impulse excitation
//  Impulse imp => Gain excite
// // when you want to excite it, do:  100*vel => imp.next; // or some scaled version

// might have to fiddle with this some, depends on modes and excitation
    50.0 => excite.gain;

    for (int i; i < NUM_MODES; i++)  {
        excite => modes[i] => dac;
        freqsNamps[i][0] => modes[i].freq; // frequencies from 
        // set these automatically here, you can do better
        setQfromT60(1.0-i/NUM_MODES,freqsNamps[i][0]) => modes[i].Q;  
        freqsNamps[i][1] => modes[i].gain;
    }

    fun float setQfromT60 (float tsixty, float centerFreq)  {  
        Math.pow(10.0,-3.0/(tsixty*second/samp)) => float rad;
        Math.log(rad) / -pi / (samp/second) => float BW;
        centerFreq / BW => float Q;
//        <<< "BW is", BW, "Q is", Q >>>;
        return Q;
    }

    fun void whackIt()  {
//        <<< modes[0].gain(), modes[1].gain(), modes[2].gain(), modes[3].gain(), modes[4].gain() >>>;
        0 => excite.pos;    // for residue excitation
//        1 => excite.keyOn; // for enveloped noise excitation
    }
    
    fun void whackItRandom(float vel)  {
        for (int i; i < 10; i++)  {  // randomize the mode gains a bit
            vel*Math.random2f(freqsNamps[i][1]/2,2*freqsNamps[i][1]) => modes[i].gain;
        }
        whackIt();
    }

    fun void whackIt(float vel)  {
        for (int i; i < 10; i++)  {  // assume lots about spatial modes
            vel*Math.random2f(freqsNamps[i][1]/2,2*freqsNamps[i][1]) => modes[i].gain;
        }
        whackIt();
    }

    // overloaded function uses position (0-1.0) for mode gains
    //   makes gross assumption that modes are 1D spatial modes
    fun void whackIt(float vel, float position)  {
        for (int i; i < NUM_MODES; i++)  {
            freqsNamps[i][0] => modes[i].freq;
            Math.sin(pi*(i+1)*position) => float temp;
            vel*temp*freqsNamps[i][1] => modes[i].gain;
        }
        whackIt();
     }
     
     fun void whackIt(float pitch, float velocity, float position)  {
         for (int i; i < NUM_MODES; i++)  {
             pitch*freqsNamps[i][0] => modes[i].freq;
             Math.sin(pi*(i+1)*position/NUM_MODES) => float temp;
             velocity*temp*freqsNamps[i][1] => modes[i].gain;
         }
         whackIt();
     }
     
 }

ModalSynth plate;

plate.whackIt();

3*second => now;
for (1 => int i; i < 11; i++) { // test "strike position" function
    plate.whackIt(0.5,i/20.0);  // move along "length" of bar (if it were a bar)
    <<< "Whack it at:", i/20.0 >>>;
    second => now;
}
second => now;

// now try out some pitch transpositions for a bit

now + 10::second => time then;

while (now < then)  {
    plate.whackIt(Math.random2f(0.7,1.6), 0.5, 0.34159);
    (Math.random2f(1,3)*0.3)::second => now;
}

